section .data
    ; Формат для вывода результатов
    fmt db 'n = %d; S = %f', 10, 0  ; 10 - символ новой строки (\n)
    
    ; Константы для вычислений
    pi dq 3.14159265358979323846    ; Число π с высокой точностью
    two dq 2.0                      ; Константа 2.0
    one dq 1.0                      ; Константа 1.0
    zero dq 0.0                     ; Константа 0.0
    max_n dd 50                     ; Максимальное значение n
    
    ; Переменные для хранения промежуточных результатов
    current_sum dq 0.0              ; Текущая сумма ряда S
    term dq 0.0                     ; Текущий член ряда
    numerator dq 0.0                ; Числитель дроби
    denominator dq 0.0              ; Знаменатель дроби
    fraction dq 0.0                 ; Дробь (2n+1)/(2n²-1)
    log_arg dq 0.0                  ; Аргумент логарифма
    power_result dq 0.0             ; Результат возведения в степень
    pi_squared dq 0.0               ; π²

section .text
    global main                     ; Точка входа для линкера
    extern printf                   ; Внешняя функция для вывода
    
    ; Объявляем внешнюю функцию pow, которую мы реализовали ранее
    extern my_pow

; Основная функция программы
main:
    ; Инициализация FPU (сопроцессора)
    finit
    
    ; Вычисляем π² для последующего использования
    fld qword [pi]                  ; Загружаем π в стек FPU (ST(0) = π)
    fld st0                         ; Копируем π (ST(0) = π, ST(1) = π)
    fmulp st1, st0                  ; Умножаем: ST(0) = π * π = π²
    fstp qword [pi_squared]         ; Сохраняем π² в память, очищаем стек FPU
    
    ; Инициализируем сумму ряда нулем
    fldz                            ; Загружаем 0.0 (ST(0) = 0.0)
    fstp qword [current_sum]        ; Сохраняем как начальную сумму
    
    ; Инициализируем счетчик цикла n = 1
    mov ecx, 1                      ; ECX = 1 (счетчик цикла)
    
    ; Начало цикла по n от 1 до max_n
cycle:
    ; Проверяем условие выхода из цикла
    cmp ecx, [max_n]                ; Сравниваем ECX с max_n
    jg end_cycle                    ; Если ECX > max_n, завершаем цикл
    
    ; === Вычисление числителя: 2n + 1 ===
    fild dword [ecx]                ; Загружаем целое n как float (ST(0) = n)
    fld qword [two]                 ; Загружаем 2.0 (ST(0) = 2.0, ST(1) = n)
    fmulp st1, st0                  ; Умножаем: ST(0) = 2.0 * n = 2n
    fld qword [one]                 ; Загружаем 1.0 (ST(0) = 1.0, ST(1) = 2n)
    faddp st1, st0                  ; Складываем: ST(0) = 2n + 1
    fstp qword [numerator]          ; Сохраняем числитель, очищаем стек
    
    ; === Вычисление знаменателя: 2n² - 1 ===
    fild dword [ecx]                ; Загружаем n (ST(0) = n)
    fld st0                         ; Копируем n (ST(0) = n, ST(1) = n)
    fmulp st1, st0                  ; Умножаем: ST(0) = n²
    fld qword [two]                 ; Загружаем 2.0 (ST(0) = 2.0, ST(1) = n²)
    fmulp st1, st0                  ; Умножаем: ST(0) = 2n²
    fld qword [one]                 ; Загружаем 1.0 (ST(0) = 1.0, ST(1) = 2n²)
    fsubp st1, st0                  ; Вычитаем: ST(0) = 2n² - 1
    fstp qword [denominator]        ; Сохраняем знаменатель, очищаем стек
    
    ; === Вычисление дроби: (2n+1)/(2n²-1) ===
    fld qword [numerator]           ; Загружаем числитель (ST(0) = 2n+1)
    fdiv qword [denominator]        ; Делим на знаменатель (ST(0) = (2n+1)/(2n²-1))
    fstp qword [fraction]           ; Сохраняем дробь
    
    ; === Проверка аргумента логарифма: 1 - fraction > 0 ===
    fld qword [one]                 ; Загружаем 1.0 (ST(0) = 1.0)
    fsub qword [fraction]           ; Вычитаем дробь (ST(0) = 1.0 - fraction)
    ftst                            ; Сравниваем результат с 0.0
    fstsw ax                        ; Сохраняем статус FPU в AX
    sahf                            ; Переносим флаги из AH в FLAGS
    jbe skip_term                   ; Если результат <= 0, пропускаем этот член
    
    ; === Вычисление логарифма: log10(1 - fraction) ===
    fld st0                         ; Копируем аргумент логарифма (ST(0) = 1-fraction, ST(1) = 1-fraction)
    fld1                            ; Загружаем 1.0 для вычисления log2(x) (ST(0) = 1.0, ST(1) = 1-fraction, ST(2) = 1-fraction)
    fxch st1                        ; Меняем местами ST(0) и ST(1) (ST(0) = 1-fraction, ST(1) = 1.0, ST(2) = 1-fraction)
    fyl2x                           ; Вычисляем log2(1-fraction) (ST(0) = log2(1-fraction), ST(1) = 1-fraction)
    fldl2t                          ; Загружаем log2(10) (ST(0) = log2(10), ST(1) = log2(1-fraction), ST(2) = 1-fraction)
    fdivrp st1, st0                 ; Делим: ST(0) = log2(1-fraction)/log2(10) = log10(1-fraction)
    fstp qword [log_arg]            ; Сохраняем результат логарифма, очищаем стек
    
    ; === Вычисление второго слагаемого: 1/(π²)ⁿ ===
    ; Сначала вычисляем (π²)ⁿ используя нашу функцию my_pow
    sub esp, 16                     ; Выделяем место для двух аргументов double (16 байт)
    
    ; Первый аргумент: основание = π²
    fld qword [pi_squared]          ; Загружаем π² (ST(0) = π²)
    fstp qword [esp]                ; Сохраняем в стек как первый аргумент my_pow
    
    ; Второй аргумент: показатель степени = n
    fild dword [ecx]                ; Загружаем n (ST(0) = n)
    fstp qword [esp + 8]            ; Сохраняем в стек как второй аргумент my_pow
    
    ; Вызываем функцию my_pow(base, exponent)
    call my_pow                     ; Результат в ST(0) = (π²)ⁿ
    
    ; Вычисляем обратное значение: 1/(π²)ⁿ
    fld1                            ; Загружаем 1.0 (ST(0) = 1.0, ST(1) = (π²)ⁿ)
    fdivrp st1, st0                 ; Делим: ST(0) = 1.0/(π²)ⁿ
    add esp, 16                     ; Очищаем выделенное место в стеке
    fstp qword [power_result]       ; Сохраняем результат, очищаем стек
    
    ; === Суммируем два слагаемых ===
    fld qword [log_arg]             ; Загружаем логарифм (ST(0) = log10(1-fraction))
    fadd qword [power_result]       ; Прибавляем степенное слагаемое (ST(0) = log10(1-fraction) + 1/(π²)ⁿ)
    fstp qword [term]               ; Сохраняем текущий член ряда
    
    ; === Добавляем текущий член к общей сумме ===
    fld qword [current_sum]         ; Загружаем текущую сумму (ST(0) = S)
    fadd qword [term]               ; Прибавляем текущий член (ST(0) = S + term)
    fstp qword [current_sum]        ; Сохраняем обновленную сумму
    
    jmp print_result                ; Переходим к выводу результата

skip_term:
    ; Если аргумент логарифма <= 0, пропускаем вычисление этого члена
    fstp st0                        ; Очищаем стек FPU от оставшегося значения
    
print_result:
    ; === Вывод результатов для текущего n ===
    sub esp, 8                      ; Выделяем место для double (8 байт)
    
    ; Подготовка аргументов для printf
    ; Сначала аргументы в обратном порядке (справа налево)
    
    ; Третий аргумент: текущая сумма S (double)
    fld qword [current_sum]         ; Загружаем текущую сумму (ST(0) = S)
    fstp qword [esp]                ; Сохраняем в стек как третий аргумент printf
    
    ; Второй аргумент: текущее значение n (int)
    push ecx                        ; Сохраняем n в стек как второй аргумент printf
    
    ; Первый аргумент: форматная строка
    push dword fmt                  ; Сохраняем адрес форматной строки как первый аргумент printf
    
    ; Вызов функции printf
    call printf
    
    ; Очистка стека после вызова printf (3 аргумента: 4 + 4 + 8 = 16 байт)
    add esp, 16
    
    ; === Переход к следующей итерации ===
    inc ecx                         ; Увеличиваем счетчик n на 1
    jmp cycle                       ; Переходим к следующей итерации цикла

end_cycle:
    ; === Завершение программы ===
    mov eax, 0                      ; Код возврата 0 (успешное завершение)
    ret                             ; Возврат из функции main