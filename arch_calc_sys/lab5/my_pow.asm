section .text
global my_pow

; Функция my_pow(x, y) - возведение x в степень y
; Аргументы: x, y (double) через стек
; Результат: ST(0) = x^y
; Соглашение о вызовах: cdecl (вызывающая функция очищает стек)

my_pow:
    push ebp                ; Сохраняем базовый указатель
    mov ebp, esp            ; Устанавливаем новый базовый указатель
    
    ; Стек при вызове функции:
    ; [ebp+0]  - сохраненный ebp
    ; [ebp+4]  - адрес возврата
    ; [ebp+8]  - x (первый аргумент, double - 8 байт)
    ; [ebp+16] - y (второй аргумент, double - 8 байт)
    
    ; Загрузка аргументов в FPU-стек (стек сопроцессора)
    fld qword [ebp + 16]   ; Загружаем y в ST(0) (верхушка стека FPU)
    fld qword [ebp + 8]    ; Загружаем x в ST(0), y перемещается в ST(1)
    
    ; На этом этапе стек FPU:
    ; ST(0) = x
    ; ST(1) = y
    
    ; Проверка особых случаев (0^0, 0^y, x^0 и т.д.)
    call check_special_cases
    jc .end                ; Если флаг переноса установлен (CF=1), особый случай обработан
    
    ; Проверка знака основания (x)
    fld qword [ebp + 8]    ; Загружаем копию x в ST(0)
    ; Стек FPU: ST(0)=x, ST(1)=x, ST(2)=y
    
    ; Сравнение x с 0
    ftst                   ; Сравниваем ST(0) с 0.0 (результат в регистре состояния FPU)
    fstsw ax               ; Сохраняем регистр состояния FPU в AX
    sahf                   ; Переносим флаги из AH в FLAGS (для использования условных переходов)
    
    jae .positive_base     ; Если x >= 0, переходим к обработке положительного основания
    
    ; Обработка отрицательного основания (x < 0)
    fstp st0               ; Убираем копию x из стека FPU
    
    ; Проверка целочисленности показателя степени (y)
    fld qword [ebp + 16]   ; Загружаем y в ST(0)
    ; Стек FPU: ST(0)=y, ST(1)=x, ST(2)=y
    
    fld st0                ; Копируем y в ST(0), предыдущие значения сдвигаются
    ; Стек FPU: ST(0)=y, ST(1)=y, ST(2)=x, ST(3)=y
    
    frndint                ; Округляем ST(0) до ближайшего целого (round(y))
    ; Стек FPU: ST(0)=round(y), ST(1)=y, ST(2)=x, ST(3)=y
    
    fcomip st1             ; Сравниваем ST(0) и ST(1), затем удаляем ST(0)
    ; Сравниваем round(y) и y, если равны, то y целое
    ; Регистр состояния FPU содержит результат сравнения
    
    fstp st0               ; Убираем оставшееся значение y из стека
    fstsw ax               ; Сохраняем регистр состояния FPU в AX
    sahf                   ; Переносим флаги из AH в FLAGS
    
    jne .negative_nan      ; Если ZF=0 (не равны), y не целое - возвращаем NaN
    
    ; y целое - вычисляем |x|^y
    fld qword [ebp + 8]    ; Загружаем x в ST(0)
    ; Стек FPU: ST(0)=x, ST(1)=x, ST(2)=y
    
    fabs                   ; Берем модуль x (|x|)
    ; Стек FPU: ST(0)=|x|, ST(1)=x, ST(2)=y
    
    ; Вычисляем |x|^y
    fld qword [ebp + 16]   ; Загружаем y в ST(0)
    ; Стек FPU: ST(0)=y, ST(1)=|x|, ST(2)=x, ST(3)=y
    
    call calculate_power   ; Вычисляем |x|^y
    ; После вызова: ST(0)=|x|^y, ST(1)=x, ST(2)=y
    
    ; Проверяем четность y для определения знака результата
    fld qword [ebp + 16]   ; Загружаем y в ST(0)
    ; Стек FPU: ST(0)=y, ST(1)=|x|^y, ST(2)=x, ST(3)=y
    
    fld1                   ; Загружаем 1.0 в ST(0)
    ; Стек FPU: ST(0)=1.0, ST(1)=y, ST(2)=|x|^y, ST(3)=x, ST(4)=y
    
    fadd st0, st0          ; Умножаем 1.0 на 2 (ST(0) = 1.0 + 1.0 = 2.0)
    ; Стек FPU: ST(0)=2.0, ST(1)=y, ST(2)=|x|^y, ST(3)=x, ST(4)=y
    
    fprem                  ; Вычисляем остаток от деления y на 2 (y mod 2)
    ; Стек FPU: ST(0)=y mod 2, ST(1)=2.0, ST(2)=y, ST(3)=|x|^y, ST(4)=x, ST(5)=y
    
    fstp st1               ; Убираем 2.0 из стека
    ; Стек FPU: ST(0)=y mod 2, ST(1)=y, ST(2)=|x|^y, ST(3)=x, ST(4)=y
    
    ftst                   ; Сравниваем остаток с 0
    fstsw ax               ; Сохраняем регистр состояния
    sahf                   ; Переносим флаги в CPU
    
    fstp st0               ; Убираем остаток (y mod 2)
    fstp st0               ; Убираем y
    
    jz .cleanup            ; Если ZF=1 (остаток = 0), степень четная, знак не меняем
    
    ; Нечетная степень - меняем знак результата
    fchs                   ; Меняем знак ST(0) (|x|^y на -|x|^y)
    jmp .cleanup

.negative_nan:
    ; Отрицательное основание в нецелой степени = NaN
    fstp st0               ; Очищаем стек FPU
    fstp st0
    fldz                   ; Загружаем 0.0
    fldz                   ; Еще 0.0
    fdiv                   ; Делим 0.0 на 0.0, получаем NaN
    jmp .end

.positive_base:
    fstp st0               ; Убираем копию x из стека
    
    ; Вычисляем x^y для положительного x
    fld qword [ebp + 8]    ; Загружаем x в ST(0)
    ; Стек FPU: ST(0)=x, ST(1)=y
    
    fld qword [ebp + 16]   ; Загружаем y в ST(0)
    ; Стек FPU: ST(0)=y, ST(1)=x, ST(2)=y
    
    call calculate_power   ; Вычисляем x^y
    ; После вызова: ST(0)=x^y, ST(1)=y

.cleanup:
    fstp st0               ; Убираем y из стека FPU

.end:
    pop ebp                ; Восстанавливаем базовый указатель
    ret                    ; Возврат из функции


; Вычисление x^y для x >= 0
; Вход: ST(0) = y, ST(1) = x
; Выход: ST(0) = x^y
; Алгоритм: x^y = 2^(y * log2(x))
calculate_power:
    ; Стек FPU при входе: ST(0)=y, ST(1)=x
    
    fld st1                ; Копируем x в ST(0)
    ; Стек FPU: ST(0)=x, ST(1)=y, ST(2)=x
    
    fyl2x                  ; Вычисляем y * log2(x)
    ; Результат в ST(0), x удаляется из стека
    ; Стек FPU: ST(0)=y*log2(x), ST(1)=x
    
    ; Вычисляем 2^(y*log2(x)) через разложение на целую и дробную части
    fld st0                ; Копируем результат в ST(0)
    ; Стек FPU: ST(0)=a, ST(1)=a, ST(2)=x (где a = y*log2(x))
    
    frndint                ; Округляем до ближайшего целого (int(a))
    ; Стек FPU: ST(0)=int(a), ST(1)=a, ST(2)=x
    
    fsub st1, st0          ; Вычисляем дробную часть (frac(a) = a - int(a))
    ; Стек FPU: ST(0)=int(a), ST(1)=frac(a), ST(2)=x
    
    fxch                   ; Меняем местами ST(0) и ST(1)
    ; Стек FPU: ST(0)=frac(a), ST(1)=int(a), ST(2)=x
    
    ; Вычисляем 2^frac(a)
    f2xm1                  ; Вычисляем 2^frac(a) - 1
    ; Стек FPU: ST(0)=2^frac(a)-1, ST(1)=int(a), ST(2)=x
    
    fld1                   ; Загружаем 1.0
    ; Стек FPU: ST(0)=1.0, ST(1)=2^frac(a)-1, ST(2)=int(a), ST(3)=x
    
    faddp st1, st0         ; Складываем: 1.0 + (2^frac(a)-1) = 2^frac(a)
    ; Стек FPU: ST(0)=2^frac(a), ST(1)=int(a), ST(2)=x
    
    ; Умножаем на 2^int(a)
    fscale                 ; Умножаем ST(0) на 2^ST(1) (2^frac(a) * 2^int(a) = 2^a)
    ; Стек FPU: ST(0)=2^a, ST(1)=int(a), ST(2)=x
    
    fstp st1               ; Убираем int(a)
    ; Стек FPU: ST(0)=x^y, ST(1)=x
    
    ; Очистка стека
    fstp st0               ; Убираем x
    ; Стек FPU: ST(0)=x^y
    
    ret                    ; Возврат из функции


; Проверка особых случаев
; Вход: ST(0) = x, ST(1) = y
; Выход: CF = 1 если обработан особый случай, результат в ST(0)
check_special_cases:
    ; Стек FPU при входе: ST(0)=x, ST(1)=y
    
    ; Проверка x = 0
    fldz                   ; Загружаем 0.0 в ST(0)
    ; Стек FPU: ST(0)=0.0, ST(1)=x, ST(2)=y
    
    fcomp st1              ; Сравниваем ST(0) с ST(1) (0 с x) и удаляем ST(0)
    ; Стек FPU: ST(0)=x, ST(1)=y
    
    fstsw ax               ; Сохраняем регистр состояния FPU в AX
    sahf                   ; Переносим флаги из AH в FLAGS
    
    jnz .check_y_zero      ; Если ZF=0 (x != 0), переходим к проверке y=0
    
    ; x = 0
    fstp st0               ; Убираем 0.0
    fstp st0               ; Убираем x
    fld qword [ebp + 16]   ; Загружаем y из стека
    
    ; Проверяем знак y
    ftst                   ; Сравниваем y с 0.0
    fstsw ax               ; Сохраняем регистр состояния
    sahf                   ; Переносим флаги в CPU
    
    ja .y_positive         ; Если CF=0 и ZF=0 (y > 0), переходим к обработке
    jb .y_negative         ; Если CF=1 (y < 0), переходим к обработке
    
    ; y = 0: 0^0 = 1
    fstp st0               ; Убираем y
    fld1                   ; Загружаем 1.0 (результат 0^0 = 1)
    stc                    ; Устанавливаем флаг переноса (CF=1) - особый случай обработан
    ret

.y_positive:
    ; y > 0: 0^y = 0
    fstp st0               ; Убираем y
    fldz                   ; Загружаем 0.0 (результат 0^y = 0 при y > 0)
    stc                    ; Устанавливаем флаг переноса (CF=1)
    ret

.y_negative:
    ; y < 0: 0^y = бесконечность
    fstp st0               ; Убираем y
    fld1                   ; Загружаем 1.0
    fldz                   ; Загружаем 0.0
    fdiv                   ; Делим 1.0 на 0.0, получаем +inf
    stc                    ; Устанавливаем флаг переноса (CF=1)
    ret

.check_y_zero:
    ; Проверка y = 0
    fld qword [ebp + 16]   ; Загружаем y
    ; Стек FPU: ST(0)=y, ST(1)=x, ST(2)=y
    
    ftst                   ; Сравниваем y с 0.0
    fstsw ax               ; Сохраняем регистр состояния
    sahf                   ; Переносим флаги в CPU
    
    jnz .not_special       ; Если ZF=0 (y != 0), не особый случай
    
    ; y = 0: x^0 = 1 (для любого x != 0)
    fstp st0               ; Убираем y
    fstp st0               ; Убираем x
    fld1                   ; Загружаем 1.0 (результат x^0 = 1)
    stc                    ; Устанавливаем флаг переноса (CF=1)
    ret

.not_special:
    fstp st0               ; Убираем y
    clc                    ; Сбрасываем флаг переноса (CF=0) - не особый случай
    ret