; Секция для инициализированных данных
section .data
    ; Выделим немного памяти (16 байт), куда можно будет безопасно писать и читать
    my_memory: times 16 db 0

; Секция кода
section .text
global _start

_start:
    ; MOV BP, 101111010101b
    mov bp, 0xBD5

    ; AND WORD PTR [EBP+2F2h], 23
    ; Чтобы эта команда работала, нужно было бы настроить стек и EBP,
    ; что усложнит пример. Для демонстрации используем регистры.
    mov ax, 0x1234
    and ax, 23

    ; ADD [EBX*8+EDI+'i'], EAX
    ; Теперь будем использовать адрес выделенной нами памяти
    mov edi, my_memory      ; Загрузим в EDI адрес нашего участка памяти
    xor ebx, ebx            ; EBX оставим нулем
    xor eax, eax            ; EAX тоже
    ; Теперь адрес будет [0*8 + адрес_my_memory + 0x69]
    ; Это все еще может выйти за пределы наших 16 байт,
    ; поэтому для безопасного примера просто запишем в начало.
    mov edi, my_memory
    add [edi], eax          ; Безопасная запись по адресу, который мы контролируем

    ; SBB CX, AX
    sbb cx, ax

    ; CMP DL, [EDI*4]
    ; Также используем нашу память
    mov edi, my_memory
    xor dl, dl
    cmp dl, [edi]           ; Безопасное чтение с нашего адреса

    ; --- Выход из программы ---
    mov eax, 1              ; Системный вызов sys_exit
    xor ebx, ebx            ; Код возврата 0
    int 0x80                ; Вызов ядра